# -*- coding=UTF-8 -*-
# This typing file was generated by typing_from_help.py
"""
adb_shell.adb_device - Implement the :class:`AdbDevice` class, which can connect to a device and run ADB shell commands.

"""

import typing
import abc
from .transport.base_transport import BaseTransport

"""
.. rubric:: Contents

* :class:`AdbDevice`

    * :meth:`AdbDevice._close`
    * :meth:`AdbDevice._filesync_flush`
    * :meth:`AdbDevice._filesync_read`
    * :meth:`AdbDevice._filesync_read_buffered`
    * :meth:`AdbDevice._filesync_read_until`
    * :meth:`AdbDevice._filesync_send`
    * :meth:`AdbDevice._transport_progress`
    * :meth:`AdbDevice._okay`
    * :meth:`AdbDevice._open`
    * :meth:`AdbDevice._pull`
    * :meth:`AdbDevice._push`
    * :meth:`AdbDevice._read`
    * :meth:`AdbDevice._read_length`
    * :meth:`AdbDevice._read_until`
    * :meth:`AdbDevice._read_until_close`
    * :meth:`AdbDevice._send`
    * :meth:`AdbDevice._service`
    * :meth:`AdbDevice._streaming_command`
    * :meth:`AdbDevice._streaming_service`
    * :meth:`AdbDevice._write`
    * :attr:`AdbDevice.available`
    * :meth:`AdbDevice.close`
    * :meth:`AdbDevice.connect`
    * :meth:`AdbDevice.list`
    * :attr:`AdbDevice.max_chunk_size`
    * :meth:`AdbDevice.pull`
    * :meth:`AdbDevice.push`
    * :meth:`AdbDevice.root`
    * :meth:`AdbDevice.shell`
    * :meth:`AdbDevice.stat`
    * :meth:`AdbDevice.streaming_shell`

* :class:`AdbDeviceTcp`
* :class:`AdbDeviceUsb`

"""

class AdbDevice(object):
    """
    AdbDevice(transport, default_transport_timeout_s=None, banner=None)

    A class with methods for connecting to a device and executing ADB commands.

    Parameters
    ----------
    transport : BaseTransport
        A user-provided transport for communicating with the device; must be an instance of a subclass of :class:`~adb_shell.transport.base_transport.BaseTransport`
    default_transport_timeout_s : float, None
        Default timeout in seconds for transport packets, or ``None``
    banner : str, bytes, None
        The hostname of the machine where the Python interpreter is currently running; if
        it is not provided, it will be determined via ``socket.gethostname()``

    Raises
    ------
    adb_shell.exceptions.InvalidTransportError
        The passed ``transport`` is not an instance of a subclass of :class:`~adb_shell.transport.base_transport.BaseTransport`

    Attributes
    ----------
    _available : bool
        Whether an ADB connection to the device has been established
    _banner : bytearray, bytes
        The hostname of the machine where the Python interpreter is currently running
    _default_transport_timeout_s : float, None
        Default timeout in seconds for transport packets, or ``None``
    _maxdata: int
        Maximum amount of data in an ADB packet
    _transport : BaseTransport
        The transport that is used to connect to the device; must be a subclass of :class:`~adb_shell.transport.base_transport.BaseTransport`
    """

    __dict__: ...
    """
    dictionary for instance variables (if defined)
    """

    __weakref__: ...
    """
    list of weak references to the object (if defined)
    """
    def __init__(self, transport, default_transport_timeout_s=None, banner=None):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    def close(self):
        """
        Close the connection via the provided transport's ``close()`` method.
        """
        ...
    def connect(
        self,
        rsa_keys: typing.Optional[typing.List[typing.Any]] = None,
        transport_timeout_s: typing.Optional[float] = None,
        auth_timeout_s: float = 10.0,
        read_timeout_s: float = 10.0,
        auth_callback: typing.Optional[typing.Callable[[], None]] = None,
    ) -> None:
        """
        Establish an ADB connection to the device.

        1. Use the transport to establish a connection
        2. Send a ``b'CNXN'`` message
        3. Unpack the ``cmd``, ``arg0``, ``arg1``, and ``banner`` fields from the response
        4. If ``cmd`` is not ``b'AUTH'``, then authentication is not necesary and so we are done
        5. If no ``rsa_keys`` are provided, raise an exception
        6. Loop through our keys, signing the last ``banner`` that we received

            1. If the last ``arg0`` was not :const:`adb_shell.constants.AUTH_TOKEN`, raise an exception
            2. Sign the last ``banner`` and send it in an ``b'AUTH'`` message
            3. Unpack the ``cmd``, ``arg0``, and ``banner`` fields from the response via :func:`adb_shell.adb_message.unpack`
            4. If ``cmd`` is ``b'CNXN'``, set transfer maxdata and return ``True``

        7. None of the keys worked, so send ``rsa_keys[0]``'s public key; if the response does not time out, we must have connected successfully


        Parameters
        ----------
        rsa_keys : list, None
            A list of signers of type :class:`~adb_shell.auth.sign_cryptography.CryptographySigner`,
            :class:`~adb_shell.auth.sign_pycryptodome.PycryptodomeAuthSigner`, or :class:`~adb_shell.auth.sign_pythonrsa.PythonRSASigner`
        transport_timeout_s : float, None
            Timeout in seconds for sending and receiving packets, or ``None``; see :meth:`BaseTransport.bulk_read() <adb_shell.transport.base_transport.BaseTransport.bulk_read>`
            and :meth:`BaseTransport.bulk_write() <adb_shell.transport.base_transport.BaseTransport.bulk_write>`
        auth_timeout_s : float, None
            The time in seconds to wait for a ``b'CNXN'`` authentication response
        read_timeout_s : float
            The total time in seconds to wait for expected commands in :meth:`AdbDevice._read`
        auth_callback : function, None
            Function callback invoked when the connection needs to be accepted on the device

        Returns
        -------
        bool
            Whether the connection was established (:attr:`AdbDevice.available`)

        Raises
        ------
        adb_shell.exceptions.DeviceAuthError
            Device authentication required, no keys available
        adb_shell.exceptions.InvalidResponseError
            Invalid auth response from the device
        """
        ...
    def exec_out(
        self,
        command,
        transport_timeout_s=None,
        read_timeout_s=10.0,
        timeout_s=None,
        decode=True,
    ):
        """
        Send an ADB ``exec-out`` command to the device.

        https://www.linux-magazine.com/Issues/2017/195/Ask-Klaus

        Parameters
        ----------
        command : str
            The exec-out command that will be sent
        transport_timeout_s : float, None
            Timeout in seconds for sending and receiving packets, or ``None``; see :meth:`BaseTransport.bulk_read() <adb_shell.transport.base_transport.BaseTransport.bulk_read>`
            and :meth:`BaseTransport.bulk_write() <adb_shell.transport.base_transport.BaseTransport.bulk_write>`
        read_timeout_s : float
            The total time in seconds to wait for a ``b'CLSE'`` or ``b'OKAY'`` command in :meth:`AdbDevice._read`
        timeout_s : float, None
            The total time in seconds to wait for the ADB command to finish
        decode : bool
            Whether to decode the output to utf8 before returning

        Returns
        -------
        bytes, str
            The output of the ADB exec-out command as a string if ``decode`` is True, otherwise as bytes.
        """
        ...
    def list(self, device_path, transport_timeout_s=None, read_timeout_s=10.0):
        """
        Return a directory listing of the given path.

        Parameters
        ----------
        device_path : str
            Directory to list.
        transport_timeout_s : float, None
            Expected timeout for any part of the pull.
        read_timeout_s : float
            The total time in seconds to wait for a ``b'CLSE'`` or ``b'OKAY'`` command in :meth:`AdbDevice._read`

        Returns
        -------
        files : list[DeviceFile]
            Filename, mode, size, and mtime info for the files in the directory
        """
        ...
    def pull(
        self,
        device_path,
        local_path,
        progress_callback=None,
        transport_timeout_s=None,
        read_timeout_s=10.0,
    ):
        """
        Pull a file from the device.

        Parameters
        ----------
        device_path : str
            The file on the device that will be pulled
        local_path : str
            The path to where the file will be downloaded
        progress_callback : function, None
            Callback method that accepts ``device_path``, ``bytes_written``, and ``total_bytes``
        transport_timeout_s : float, None
            Expected timeout for any part of the pull.
        read_timeout_s : float
            The total time in seconds to wait for a ``b'CLSE'`` or ``b'OKAY'`` command in :meth:`AdbDevice._read`
        """
        ...
    def push(
        self,
        local_path,
        device_path,
        st_mode=33272,
        mtime=0,
        progress_callback=None,
        transport_timeout_s=None,
        read_timeout_s=10.0,
    ):
        """
        Push a file or directory to the device.

        Parameters
        ----------
        local_path : str
            Either a filename or a directory to push to the device.
        device_path : str
            Destination on the device to write to.
        st_mode : int
            Stat mode for ``local_path``
        mtime : int
            Modification time to set on the file.
        progress_callback : function, None
            Callback method that accepts ``device_path``, ``bytes_written``, and ``total_bytes``
        transport_timeout_s : float, None
            Expected timeout for any part of the push.
        read_timeout_s : float
            The total time in seconds to wait for a ``b'CLSE'`` or ``b'OKAY'`` command in :meth:`AdbDevice._read`
        """
        ...
    def root(self, transport_timeout_s=None, read_timeout_s=10.0, timeout_s=None):
        """
        Gain root access.

        The device must be rooted in order for this to work.

        Parameters
        ----------
        transport_timeout_s : float, None
            Timeout in seconds for sending and receiving packets, or ``None``; see :meth:`BaseTransport.bulk_read() <adb_shell.transport.base_transport.BaseTransport.bulk_read>`
            and :meth:`BaseTransport.bulk_write() <adb_shell.transport.base_transport.BaseTransport.bulk_write>`
        read_timeout_s : float
            The total time in seconds to wait for a ``b'CLSE'`` or ``b'OKAY'`` command in :meth:`AdbDevice._read`
        timeout_s : float, None
            The total time in seconds to wait for the ADB command to finish
        """
        ...
    @typing.overload
    def shell(
        self,
        command: typing.Text,
        transport_timeout_s: typing.Optional[float] = None,
        read_timeout_s: float = 10.0,
        timeout_s: typing.Optional[float] = None,
    ) -> typing.Text: ...
    @typing.overload
    def shell(
        self,
        command: typing.Text,
        transport_timeout_s: typing.Optional[float] = None,
        read_timeout_s: float = 10.0,
        timeout_s: typing.Optional[float] = None,
        decode: typing.Literal[True] = ...,
    ) -> typing.Text: ...
    @typing.overload
    def shell(
        self,
        command: typing.Text,
        transport_timeout_s: typing.Optional[float] = None,
        read_timeout_s: float = 10.0,
        timeout_s: typing.Optional[float] = None,
        decode: typing.Literal[False] = ...,
    ) -> bytes: ...
    @typing.overload
    def shell(
        self,
        command: typing.Text,
        transport_timeout_s: typing.Optional[float] = None,
        read_timeout_s: float = 10.0,
        timeout_s: typing.Optional[float] = None,
        decode: bool = True,
    ) -> typing.Union[typing.Text, bytes]:
        """
        Send an ADB shell command to the device.

        Parameters
        ----------
        command : str
            The shell command that will be sent
        transport_timeout_s : float, None
            Timeout in seconds for sending and receiving packets, or ``None``; see :meth:`BaseTransport.bulk_read() <adb_shell.transport.base_transport.BaseTransport.bulk_read>`
            and :meth:`BaseTransport.bulk_write() <adb_shell.transport.base_transport.BaseTransport.bulk_write>`
        read_timeout_s : float
            The total time in seconds to wait for a ``b'CLSE'`` or ``b'OKAY'`` command in :meth:`AdbDevice._read`
        timeout_s : float, None
            The total time in seconds to wait for the ADB command to finish
        decode : bool
            Whether to decode the output to utf8 before returning

        Returns
        -------
        bytes, str
            The output of the ADB shell command as a string if ``decode`` is True, otherwise as bytes.
        """
        ...
    def stat(self, device_path, transport_timeout_s=None, read_timeout_s=10.0):
        """
        Get a file's ``stat()`` information.

        Parameters
        ----------
        device_path : str
            The file on the device for which we will get information.
        transport_timeout_s : float, None
            Expected timeout for any part of the pull.
        read_timeout_s : float
            The total time in seconds to wait for a ``b'CLSE'`` or ``b'OKAY'`` command in :meth:`AdbDevice._read`

        Returns
        -------
        mode : int
            The octal permissions for the file
        size : int
            The size of the file
        mtime : int
            The last modified time for the file
        """
        ...
    def streaming_shell(
        self, command, transport_timeout_s=None, read_timeout_s=10.0, decode=True
    ):
        """
        Send an ADB shell command to the device, yielding each line of output.

        Parameters
        ----------
        command : str
            The shell command that will be sent
        transport_timeout_s : float, None
            Timeout in seconds for sending and receiving packets, or ``None``; see :meth:`BaseTransport.bulk_read() <adb_shell.transport.base_transport.BaseTransport.bulk_read>`
            and :meth:`BaseTransport.bulk_write() <adb_shell.transport.base_transport.BaseTransport.bulk_write>`
        read_timeout_s : float
            The total time in seconds to wait for a ``b'CLSE'`` or ``b'OKAY'`` command in :meth:`AdbDevice._read`
        decode : bool
            Whether to decode the output to utf8 before returning

        Yields
        -------
        bytes, str
            The line-by-line output of the ADB shell command as a string if ``decode`` is True, otherwise as bytes.
        """
        ...
    ...

class AdbDeviceTcp(AdbDevice):
    """
    AdbDeviceTcp(host, port=5555, default_transport_timeout_s=None, banner=None)

    A class with methods for connecting to a device via TCP and executing ADB commands.

    Parameters
    ----------
    host : str
        The address of the device; may be an IP address or a host name
    port : int
        The device port to which we are connecting (default is 5555)
    default_transport_timeout_s : float, None
        Default timeout in seconds for TCP packets, or ``None``
    banner : str, bytes, None
        The hostname of the machine where the Python interpreter is currently running; if
        it is not provided, it will be determined via ``socket.gethostname()``

    Attributes
    ----------
    _available : bool
        Whether an ADB connection to the device has been established
    _banner : bytearray, bytes
        The hostname of the machine where the Python interpreter is currently running
    _default_transport_timeout_s : float, None
        Default timeout in seconds for TCP packets, or ``None``
    _maxdata : int
        Maximum amount of data in an ADB packet
    _transport : TcpTransport
        The transport that is used to connect to the device
    """

    def __init__(
        self,
        host: typing.Text,
        port: int = 5555,
        default_transport_timeout_s: int = None,
        banner: typing.Text = None,
    ):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    ...

class AdbDeviceUsb(AdbDevice):
    """
    AdbDeviceUsb(serial=None, port_path=None, default_transport_timeout_s=None, banner=None)

    A class with methods for connecting to a device via USB and executing ADB commands.

    Parameters
    ----------
    serial : str, None
        The USB device serial ID
    port_path : TODO, None
        TODO
    default_transport_timeout_s : float, None
        Default timeout in seconds for USB packets, or ``None``
    banner : str, bytes, None
        The hostname of the machine where the Python interpreter is currently running; if
        it is not provided, it will be determined via ``socket.gethostname()``

    Raises
    ------
    adb_shell.exceptions.InvalidTransportError
        Raised if package was not installed with the "usb" extras option (``pip install adb-shell[usb]``)

    Attributes
    ----------
    _available : bool
        Whether an ADB connection to the device has been established
    _banner : bytearray, bytes
        The hostname of the machine where the Python interpreter is currently running
    _default_transport_timeout_s : float, None
        Default timeout in seconds for USB packets, or ``None``
    _maxdata : int
        Maximum amount of data in an ADB packet
    _transport : UsbTransport
        The transport that is used to connect to the device
    """

    def __init__(
        self, serial=None, port_path=None, default_transport_timeout_s=None, banner=None
    ):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    ...

class AdbMessage(object):
    """
    AdbMessage(command, arg0, arg1, data=b'')

    A helper class for packing ADB messages.

    Parameters
    ----------
    command : bytes
        A command; examples used in this package include :const:`adb_shell.constants.AUTH`, :const:`adb_shell.constants.CNXN`, :const:`adb_shell.constants.CLSE`, :const:`adb_shell.constants.OPEN`, and :const:`adb_shell.constants.OKAY`
    arg0 : int
        Usually the local ID, but :meth:`~adb_shell.adb_device.AdbDevice.connect` and :meth:`~adb_shell.adb_device_async.AdbDeviceAsync.connect` provide :const:`adb_shell.constants.VERSION`, :const:`adb_shell.constants.AUTH_SIGNATURE`, and :const:`adb_shell.constants.AUTH_RSAPUBLICKEY`
    arg1 : int
        Usually the remote ID, but :meth:`~adb_shell.adb_device.AdbDevice.connect` and :meth:`~adb_shell.adb_device_async.AdbDeviceAsync.connect` provide :const:`adb_shell.constants.MAX_ADB_DATA`
    data : bytes
        The data that will be sent

    Attributes
    ----------
    arg0 : int
        Usually the local ID, but :meth:`~adb_shell.adb_device.AdbDevice.connect` and :meth:`~adb_shell.adb_device_async.AdbDeviceAsync.connect` provide :const:`adb_shell.constants.VERSION`, :const:`adb_shell.constants.AUTH_SIGNATURE`, and :const:`adb_shell.constants.AUTH_RSAPUBLICKEY`
    arg1 : int
        Usually the remote ID, but :meth:`~adb_shell.adb_device.AdbDevice.connect` and :meth:`~adb_shell.adb_device_async.AdbDeviceAsync.connect` provide :const:`adb_shell.constants.MAX_ADB_DATA`
    command : int
        The input parameter ``command`` converted to an integer via :const:`adb_shell.constants.ID_TO_WIRE`
    data : bytes
        The data that will be sent
    magic : int
        ``self.command`` with its bits flipped; in other words, ``self.command + self.magic == 2**32 - 1``
    """

    __dict__: ...
    """
    dictionary for instance variables (if defined)
    """

    __weakref__: ...
    """
    list of weak references to the object (if defined)
    """
    def __init__(self, command, arg0, arg1, data=b""):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    def pack(self):
        """
        Returns this message in an over-the-wire format.

        Returns
        -------
        bytes
            The message packed into the format required by ADB
        """
        ...
    ...

class BaseTransport(abc.ABC):
    """
    A base transport class.
    """

    __abstractmethods__: ...
    """
    """
    def bulk_read(self, numbytes, transport_timeout_s):
        """
        Read data from the device.

        Parameters
        ----------
        numbytes : int
            The maximum amount of data to be received
        transport_timeout_s : float, None
            A timeout for the read operation

        Returns
        -------
        bytes
            The received data
        """
        ...
    def bulk_write(self, data, transport_timeout_s):
        """
        Send data to the device.

        Parameters
        ----------
        data : bytes
            The data to be sent
        transport_timeout_s : float, None
            A timeout for the write operation

        Returns
        -------
        int
            The number of bytes sent
        """
        ...
    def close(self):
        """
        Close the connection.
        """
        ...
    def connect(self, transport_timeout_s):
        """
        Create a connection to the device.

        Parameters
        ----------
        transport_timeout_s : float, None
            A connection timeout
        """
        ...
    ...

class DeviceFile(tuple):
    """
    DeviceFile(filename, mode, size, mtime)

    DeviceFile(filename, mode, size, mtime)
    """

    _field_defaults: ...
    """
    """

    _fields: ... = ("filename", "mode", "size", "mtime")
    """
    """

    _fields_defaults: ...
    """
    """
    @staticmethod
    def __new__(_cls, filename, mode, size, mtime):
        """
        Create new instance of DeviceFile(filename, mode, size, mtime)
        """
        ...
    @classmethod
    def _make(cls, iterable):
        """
        Make a new DeviceFile object from a sequence or iterable
        """
        ...
    def __getnewargs__(self):
        """
        Return self as a plain tuple.  Used by copy and pickle.
        """
        ...
    def __repr__(self):
        """
        Return a nicely formatted representation string
        """
        ...
    def _asdict(self):
        """
        Return a new dict which maps field names to their values.
        """
        ...
    def _replace(self, /, **kwds):
        """
        Return a new DeviceFile object replacing specified fields with new values
        """
        ...
    ...

class TcpTransport(BaseTransport):
    """
    TcpTransport(host, port=5555)

    TCP connection object.

    Parameters
    ----------
    host : str
        The address of the device; may be an IP address or a host name
    port : int
        The device port to which we are connecting (default is 5555)

    Attributes
    ----------
    _connection : socket.socket, None
        A socket connection to the device
    _host : str
        The address of the device; may be an IP address or a host name
    _port : int
        The device port to which we are connecting (default is 5555)
    """

    __abstractmethods__: ... = frozenset()
    """
    """
    def __init__(self, host, port=5555):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    def bulk_read(self, numbytes, transport_timeout_s):
        """
        Receive data from the socket.

        Parameters
        ----------
        numbytes : int
            The maximum amount of data to be received
        transport_timeout_s : float, None
            When the timeout argument is omitted, ``select.select`` blocks until at least one file descriptor is ready. A time-out value of zero specifies a poll and never blocks.

        Returns
        -------
        bytes
            The received data

        Raises
        ------
        TcpTimeoutException
            Reading timed out.
        """
        ...
    def bulk_write(self, data, transport_timeout_s):
        """
        Send data to the socket.

        Parameters
        ----------
        data : bytes
            The data to be sent
        transport_timeout_s : float, None
            When the timeout argument is omitted, ``select.select`` blocks until at least one file descriptor is ready. A time-out value of zero specifies a poll and never blocks.

        Returns
        -------
        int
            The number of bytes sent

        Raises
        ------
        TcpTimeoutException
            Sending data timed out.  No data was sent.
        """
        ...
    def close(self):
        """
        Close the socket connection.
        """
        ...
    def connect(self, transport_timeout_s):
        """
        Create a socket connection to the device.

        Parameters
        ----------
        transport_timeout_s : float, None
            Set the timeout on the socket instance
        """
        ...
    ...

class _AdbTransactionInfo(object):
    """
    _AdbTransactionInfo(local_id, remote_id, transport_timeout_s=None, read_timeout_s=10.0, timeout_s=None)

    A class for storing info and settings used during a single ADB "transaction."

    Note that if ``timeout_s`` is not ``None``, then:

    ::

       self.transport_timeout_s <= self.read_timeout_s <= self.timeout_s

    If ``timeout_s`` is ``None``, the first inequality still applies.


    Parameters
    ----------
    local_id : int
        The ID for the sender (i.e., the device running this code)
    remote_id : int
        The ID for the recipient
    transport_timeout_s : float, None
        Timeout in seconds for sending and receiving packets, or ``None``; see :meth:`BaseTransport.bulk_read() <adb_shell.transport.base_transport.BaseTransport.bulk_read>`,
        :meth:`BaseTransport.bulk_write() <adb_shell.transport.base_transport.BaseTransport.bulk_write>`,
        :meth:`BaseTransportAsync.bulk_read() <adb_shell.transport.base_transport_async.BaseTransportAsync.bulk_read>`, and
        :meth:`BaseTransportAsync.bulk_write() <adb_shell.transport.base_transport_async.BaseTransportAsync.bulk_write>`
    read_timeout_s : float
        The total time in seconds to wait for a command in ``expected_cmds`` in :meth:`AdbDevice._read` and :meth:`AdbDeviceAsync._read`
    timeout_s : float, None
        The total time in seconds to wait for the ADB command to finish

    Attributes
    ----------
    local_id : int
        The ID for the sender (i.e., the device running this code)
    read_timeout_s : float
        The total time in seconds to wait for a command in ``expected_cmds`` in :meth:`AdbDevice._read` and :meth:`AdbDeviceAsync._read`
    remote_id : int
        The ID for the recipient
    timeout_s : float, None
        The total time in seconds to wait for the ADB command to finish
    transport_timeout_s : float, None
        Timeout in seconds for sending and receiving packets, or ``None``; see :meth:`BaseTransport.bulk_read() <adb_shell.transport.base_transport.BaseTransport.bulk_read>`,
        :meth:`BaseTransport.bulk_write() <adb_shell.transport.base_transport.BaseTransport.bulk_write>`,
        :meth:`BaseTransportAsync.bulk_read() <adb_shell.transport.base_transport_async.BaseTransportAsync.bulk_read>`, and
        :meth:`BaseTransportAsync.bulk_write() <adb_shell.transport.base_transport_async.BaseTransportAsync.bulk_write>`
    """

    __dict__: ...
    """
    dictionary for instance variables (if defined)
    """

    __weakref__: ...
    """
    list of weak references to the object (if defined)
    """
    def __init__(
        self,
        local_id,
        remote_id,
        transport_timeout_s=None,
        read_timeout_s=10.0,
        timeout_s=None,
    ):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    ...

class _FileSyncTransactionInfo(object):
    """
    _FileSyncTransactionInfo(recv_message_format, maxdata=1048576)

    A class for storing info used during a single FileSync "transaction."

    Parameters
    ----------
    recv_message_format : bytes
        The FileSync message format
    maxdata: int
        Maximum amount of data in an ADB packet

    Attributes
    ----------
    _maxdata: int
        Maximum amount of data in an ADB packet
    recv_buffer : bytearray
        A buffer for storing received data
    recv_message_format : bytes
        The FileSync message format
    recv_message_size : int
        The FileSync message size
    send_buffer : bytearray
        A buffer for storing data to be sent
    send_idx : int
        The index in ``recv_buffer`` that will be the start of the next data packet sent
    """

    __dict__: ...
    """
    dictionary for instance variables (if defined)
    """

    __weakref__: ...
    """
    list of weak references to the object (if defined)
    """
    def __init__(self, recv_message_format, maxdata=1048576):
        """
        Initialize self.  See help(type(self)) for accurate signature.
        """
        ...
    def can_add_to_send_buffer(self, data_len):
        """
        Determine whether ``data_len`` bytes of data can be added to the send buffer without exceeding :const:`constants.MAX_ADB_DATA`.

        Parameters
        ----------
        data_len : int
            The length of the data to be potentially added to the send buffer (not including the length of its header)

        Returns
        -------
        bool
            Whether ``data_len`` bytes of data can be added to the send buffer without exceeding :const:`constants.MAX_ADB_DATA`
        """
        ...
    ...

def checksum(data):
    """
    Calculate the checksum of the provided data.

    Parameters
    ----------
    data : bytearray, bytes, str
        The data

    Returns
    -------
    int
        The checksum
    """
    ...

def get_banner():
    """
    Get the ``banner`` that will be signed in :meth:`adb_shell.adb_device.AdbDevice.connect` / :meth:`adb_shell.adb_device_async.AdbDeviceAsync.connect`.

    Returns
    -------
    bytearray
        The hostname, or "unknown" if it could not be determined
    """
    ...

def get_files_to_push(local_path, device_path):
    """
    Get a list of the file(s) to push.

    Parameters
    ----------
    local_path : str
        A path to a local file or directory
    device_path : str
        A path to a file or directory on the device

    Returns
    -------
    local_path_is_dir : bool
        Whether or not ``local_path`` is a directory
    local_paths : list[str]
        A list of the file(s) to push
    device_paths : list[str]
        A list of destination paths on the device that corresponds to ``local_paths``
    """
    ...

def int_to_cmd(n):
    """
    Convert from an integer (4 bytes) to an ADB command.

    Parameters
    ----------
    n : int
        The integer that will be converted to an ADB command

    Returns
    -------
    str
        The ADB command (e.g., ``'CNXN'``)
    """
    ...

def unpack(message):
    """
    Unpack a received ADB message.

    Parameters
    ----------
    message : bytes
        The received message

    Returns
    -------
    cmd : int
        The ADB command
    arg0 : int
        TODO
    arg1 : int
        TODO
    data_length : int
        The length of the data sent by the device (used by :meth:`adb_shell.adb_device.AdbDevice._read` and :meth:`adb_shell.adb_device_async.AdbDeviceAsync._read`)
    data_checksum : int
        The checksum of the data sent by the device

    Raises
    ------
    ValueError
        Unable to unpack the ADB command.
    """
    ...

UsbTransport: ... = None

_LOGGER: ...
"""
<Logger adb_shell.adb_device (WARNING)>
"""

__all__: ...
"""
['AdbDevice', 'AdbDeviceTcp', 'AdbDeviceUsb', 'AdbMessage', ...
"""
